name: Deploy Data Services

on:
  push:
    branches:
      - main
      - develop
    # paths:
    #   - 'data/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

jobs:
  build-and-deploy:
    name: Build and Deploy Data Services
    runs-on: ubuntu-latest
    environment: production
    
    env:
      DOCTL_VERSION: 1.92.1
      KUBE_CLUSTER_ID: ${{ secrets.DO_KUBERNETES_CLUSTER_ID }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
      POSTGRES_DB_POSEY: ${{ secrets.POSTGRES_DB_POSEY }}
      POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
      COUCHBASE_USER: ${{ secrets.COUCHBASE_USER }}
      COUCHBASE_PASSWORD: ${{ secrets.COUCHBASE_PASSWORD }}
      COUCHBASE_BUCKET: ${{ secrets.COUCHBASE_BUCKET }}
      GRAPH_API_SECRET: ${{ secrets.GRAPH_API_SECRET }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          
      - name: Enable Corepack
        run: |
          corepack enable
          yarn --version
          
      - name: Install dependencies
        run: |
          cd data
          yarn install
        
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}
          
      - name: Login to DigitalOcean Container Registry
        run: doctl registry login --expiry-seconds 1200
        
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Save DigitalOcean kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ secrets.DO_KUBERNETES_CLUSTER_ID }}
        
      - name: Debug environment variables
        run: |
          echo "Checking environment variables:"
          echo "POSTGRES_USER: ${{ secrets.POSTGRES_USER }}"
          echo "POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}"
          echo "POSTGRES_DB_POSEY: ${{ secrets.POSTGRES_DB_POSEY }}"
          echo "POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}"
        
      - name: Build Docker images
        run: |
          cd data
          # First, let's modify the .env file with correct values
          cat > .env << EOF
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}
          POSTGRES_DB_POSEY=${{ secrets.POSTGRES_DB_POSEY }}
          POSTGRES_HOST=${{ secrets.POSTGRES_HOST }}
          COUCHBASE_USER=${{ secrets.COUCHBASE_USER }}
          COUCHBASE_PASSWORD=${{ secrets.COUCHBASE_PASSWORD }}
          COUCHBASE_BUCKET=${{ secrets.COUCHBASE_BUCKET }}
          QDRANT_API_KEY=${{ secrets.QDRANT_API_KEY }}
          GRAPH_API_SECRET=${{ secrets.GRAPH_API_SECRET }}
          ENVIRONMENT=${{ github.event.inputs.environment || (github.ref_name == 'main' && 'production' || 'staging') }}
          DOCKER_REGISTRY=registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}
          EOF
          
          # Show the build.ts script content to debug
          echo "Content of build script:"
          cat scripts/build.ts
          
          # Run the build command with verbose logging
          yarn build --verbose
          
          # List the docker-compose.yml file to verify services
          echo "Docker compose services:"
          cat docker-compose.yml
          
      - name: Check available Docker images
        run: |
          echo "Available Docker images:"
          docker images
          
          # Build the images manually if needed
          cd data
          
          # Try using docker-compose directly
          docker-compose build
          
          # List images again
          echo "Docker images after docker-compose build:"
          docker images
          
          # If still no images, try building each service manually
          if ! docker images | grep -q 'posey-'; then
            echo "No posey images found, building each service individually"
            for service in postgres couchbase vector.db graphql; do
              service_dir=$(echo $service | tr '.' '-')
              echo "Building service: $service from directory $service_dir"
              
              # Check if the service directory has a Dockerfile
              if [ -f "$service/Dockerfile" ]; then
                docker build -t posey-$service_dir:latest $service
              else
                echo "No Dockerfile found in $service directory, checking docker-compose"
                # If no Dockerfile, try docker-compose
                docker-compose -f docker-compose.yml build $service || echo "Failed to build $service"
              fi
            done
            
            # List images again
            echo "Docker images after manual build:"
            docker images
          fi
        
      - name: Tag and push Docker images
        run: |
          # Get the short SHA of the commit
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          
          # Get all posey images from docker-compose
          POSEY_IMAGES=$(docker images | grep 'posey' | awk '{print $1}')
          
          if [ -z "$POSEY_IMAGES" ]; then
            echo "No posey images found to push"
            exit 1
          fi
          
          echo "Found posey images: $POSEY_IMAGES"
          
          # Tag and push all posey images
          for IMAGE in $POSEY_IMAGES; do
            IMAGE_NAME=$(echo $IMAGE | sed 's/posey-//')
            echo "Tagging and pushing $IMAGE as $IMAGE_NAME"
            
            # Tag with SHA and latest
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/$IMAGE:$SHORT_SHA
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/$IMAGE:latest
            
            # Push both tags
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/$IMAGE:$SHORT_SHA
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/$IMAGE:latest
          done
        
      - name: Update .env file with deployment variables
        run: |
          cd data
          
          # Update environment variables for deployment
          cat > .env << EOF
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}
          POSTGRES_DB_POSEY=${{ secrets.POSTGRES_DB_POSEY }}
          POSTGRES_HOST=${{ secrets.POSTGRES_HOST }}
          COUCHBASE_USER=${{ secrets.COUCHBASE_USER }}
          COUCHBASE_PASSWORD=${{ secrets.COUCHBASE_PASSWORD }}
          COUCHBASE_BUCKET=${{ secrets.COUCHBASE_BUCKET }}
          QDRANT_API_KEY=${{ secrets.QDRANT_API_KEY }}
          GRAPH_API_SECRET=${{ secrets.GRAPH_API_SECRET }}
          ENVIRONMENT=${{ github.event.inputs.environment || (github.ref_name == 'main' && 'production' || 'staging') }}
          DOCKER_REGISTRY=registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}
          EOF
        
      - name: Deploy to Kubernetes
        run: |
          cd data
          yarn deploy
        
      - name: Verify deployment
        run: |
          kubectl get pods -n posey
          
      - name: Notify on success
        if: success()
        run: |
          echo "✅ Data services deployment successful"
          
      - name: Notify on failure
        if: failure()
        run: |
          echo "❌ Data services deployment failed" 