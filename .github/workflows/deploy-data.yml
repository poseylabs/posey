name: Deploy Data Services

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'data/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

jobs:
  build-and-deploy-data:
    name: Build and Deploy Data Services
    runs-on: ubuntu-latest
    # Match the exact environment name as shown in GitHub UI
    environment: PRODUCTION
    
    env:
      DOCTL_VERSION: 1.92.1
      KUBE_CLUSTER_ID: ${{ secrets.DO_KUBERNETES_CLUSTER_ID }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
      POSTGRES_DB_POSEY: ${{ secrets.POSTGRES_DB_POSEY }}
      POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
      COUCHBASE_USER: ${{ secrets.COUCHBASE_USER }}
      COUCHBASE_PASSWORD: ${{ secrets.COUCHBASE_PASSWORD }}
      COUCHBASE_BUCKET: ${{ secrets.COUCHBASE_BUCKET }}
      GRAPH_API_SECRET: ${{ secrets.GRAPH_API_SECRET }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Debug Secrets
        run: |
          echo "Debugging available secrets (will show only if exist, not values):"
          if [ -n "${{ secrets.POSTGRES_USER }}" ]; then echo "POSTGRES_USER: exists"; else echo "POSTGRES_USER: missing"; fi
          if [ -n "${{ secrets.POSTGRES_PASSWORD }}" ]; then echo "POSTGRES_PASSWORD: exists"; else echo "POSTGRES_PASSWORD: missing"; fi
          if [ -n "${{ secrets.POSTGRES_PORT }}" ]; then echo "POSTGRES_PORT: exists"; else echo "POSTGRES_PORT: missing"; fi
          if [ -n "${{ secrets.POSTGRES_DB_POSEY }}" ]; then echo "POSTGRES_DB_POSEY: exists"; else echo "POSTGRES_DB_POSEY: missing"; fi
          if [ -n "${{ secrets.POSTGRES_HOST }}" ]; then echo "POSTGRES_HOST: exists"; else echo "POSTGRES_HOST: missing"; fi

          # Check for alternative names seen in your variables screenshot
          if [ -n "${{ secrets.POSTGRES_DB }}" ]; then echo "POSTGRES_DB: exists"; else echo "POSTGRES_DB: missing"; fi
          if [ -n "${{ secrets.POSTGRES_USER }}" ]; then echo "POSTGRES_USER: exists"; else echo "POSTGRES_USER: missing"; fi

          # Debug GitHub context to understand available data
          echo "GITHUB_REPOSITORY: $GITHUB_REPOSITORY"
          echo "GITHUB_REF_NAME: $GITHUB_REF_NAME"
          echo "GITHUB_WORKFLOW: $GITHUB_WORKFLOW"

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Enable Corepack
        run: |
          corepack enable
          yarn --version

      - name: Install dependencies
        run: |
          cd data
          yarn install

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}

      - name: Login to DigitalOcean Container Registry
        run: |
          # Debug API token availability (don't print the actual token!)
          if [ -n "${{ secrets.DO_API_TOKEN }}" ]; then echo "DO_API_TOKEN exists"; else echo "DO_API_TOKEN missing"; fi

          # Debug registry name
          echo "Registry name: ${{ secrets.DO_REGISTRY_NAME }}"

          # Login with longer expiry to ensure enough time
          doctl registry login --expiry-seconds 3600

          # Verify login worked
          echo "Checking registry access..."
          doctl registry repository list || echo "Failed to list repositories"
        
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Save DigitalOcean kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ secrets.DO_KUBERNETES_CLUSTER_ID }}
        
      - name: Export environment variables directly
        run: |
          # Export variables directly to make them available to all steps
          echo "POSTGRES_USER=${{ secrets.POSTGRES_USER }}" >> $GITHUB_ENV
          echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" >> $GITHUB_ENV
          echo "POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}" >> $GITHUB_ENV
          echo "POSTGRES_DB_POSEY=${{ secrets.POSTGRES_DB_POSEY }}" >> $GITHUB_ENV
          echo "POSTGRES_HOST=${{ secrets.POSTGRES_HOST }}" >> $GITHUB_ENV
          echo "COUCHBASE_USER=${{ secrets.COUCHBASE_USER }}" >> $GITHUB_ENV
          echo "COUCHBASE_PASSWORD=${{ secrets.COUCHBASE_PASSWORD }}" >> $GITHUB_ENV
          echo "COUCHBASE_BUCKET=${{ secrets.COUCHBASE_BUCKET }}" >> $GITHUB_ENV
          echo "GRAPH_API_SECRET=${{ secrets.GRAPH_API_SECRET }}" >> $GITHUB_ENV
          
          # Use hardcoded values as fallbacks for testing if needed
          if [ -z "$POSTGRES_USER" ]; then
            echo "POSTGRES_USER=pocketprod" >> $GITHUB_ENV
          fi
          if [ -z "$POSTGRES_PORT" ]; then
            echo "POSTGRES_PORT=3333" >> $GITHUB_ENV
          fi
          if [ -z "$POSTGRES_DB_POSEY" ]; then
            echo "POSTGRES_DB_POSEY=poseybase" >> $GITHUB_ENV
          fi
          if [ -z "$POSTGRES_HOST" ]; then
            echo "POSTGRES_HOST=posey-postgres" >> $GITHUB_ENV
          fi
          
          # Set environment based on branch
          if [ "$GITHUB_REF_NAME" = "main" ]; then
            echo "DEPLOY_ENV=production" >> $GITHUB_ENV
          else
            echo "DEPLOY_ENV=staging" >> $GITHUB_ENV
          fi
        
      - name: Verify environment variables
        run: |
          echo "Checking environment variables after export:"
          echo "POSTGRES_USER: $POSTGRES_USER"
          echo "POSTGRES_PORT: $POSTGRES_PORT"
          echo "POSTGRES_DB_POSEY: $POSTGRES_DB_POSEY"
          echo "POSTGRES_HOST: $POSTGRES_HOST"
          echo "DEPLOY_ENV: $DEPLOY_ENV"
        
      - name: Build Docker images
        run: |
          cd data
          # Create .env file with exported variables
          cat > .env << EOF
          POSTGRES_USER=$POSTGRES_USER
          POSTGRES_PASSWORD=$POSTGRES_PASSWORD
          POSTGRES_PORT=$POSTGRES_PORT
          POSTGRES_DB_POSEY=$POSTGRES_DB_POSEY
          POSTGRES_HOST=$POSTGRES_HOST
          COUCHBASE_USER=$COUCHBASE_USER
          COUCHBASE_PASSWORD=$COUCHBASE_PASSWORD
          COUCHBASE_BUCKET=$COUCHBASE_BUCKET
          ENVIRONMENT=$DEPLOY_ENV
          DOCKER_REGISTRY=registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}
          EOF
          
          # Display .env file
          echo "Created .env file:"
          cat .env
          
          # Show the build.ts script content
          echo "Content of build script:"
          cat scripts/build.ts || echo "build.ts not found"
          
          # Run the build command
          yarn build || echo "Build failed, proceeding with manual build"
          
      - name: Check available Docker images
        run: |
          echo "Available Docker images:"
          docker images
        
      - name: Tag and push Docker images
        run: |
          # Debug secrets and environment variables
          echo "Checking critical variables:"
          echo "DO_REGISTRY_NAME: ${{ secrets.DO_REGISTRY_NAME }}"
          echo "GITHUB_SHA: ${GITHUB_SHA}"
          
          # Get the short SHA of the commit
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          echo "Using commit SHA: ${SHORT_SHA}"
          
          # Get all posey images from docker-compose
          POSEY_IMAGES=$(docker images | grep 'posey' | awk '{print $1}')
          
          if [ -z "$POSEY_IMAGES" ]; then
            echo "No posey images found to push"
            exit 1
          fi

          echo "Found posey images: $POSEY_IMAGES"
          
          # Refresh registry login just before pushing
          echo "Refreshing registry login..."
          doctl registry login --expiry-seconds 3600
          
          # Tag and push all posey images
          for IMAGE in $POSEY_IMAGES; do
            echo "Tagging and pushing $IMAGE"

            # Extract the image name without registry prefix
            IMAGE_NAME=$(echo $IMAGE | sed 's|registry.digitalocean.com/posey/||')
            echo "Extracted image name: $IMAGE_NAME"
            
            # Use only the image name for tagging with registry from secrets
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${SHORT_SHA}
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:latest
            
            echo "Tagged images. Pushing to registry..."
            
            # Push both tags
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${SHORT_SHA} && echo "Successfully pushed SHA tag"
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:latest && echo "Successfully pushed latest tag"
          done
        
      - name: Deploy to Kubernetes
        run: |
          cd data
          # Create .env file for deployment
          cat > .env << EOF
          POSTGRES_USER=$POSTGRES_USER
          POSTGRES_PASSWORD=$POSTGRES_PASSWORD
          POSTGRES_PORT=$POSTGRES_PORT
          POSTGRES_DB_POSEY=$POSTGRES_DB_POSEY
          POSTGRES_HOST=$POSTGRES_HOST
          COUCHBASE_USER=$COUCHBASE_USER
          COUCHBASE_PASSWORD=$COUCHBASE_PASSWORD
          COUCHBASE_BUCKET=$COUCHBASE_BUCKET
          ENVIRONMENT=$DEPLOY_ENV
          DOCKER_REGISTRY=registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}
          EOF
          
          # Check for existing StatefulSets and handle them
          echo "Checking for existing StatefulSets..."
          
          # Handle Postgres StatefulSet
          if kubectl get statefulset postgres -n posey &>/dev/null; then
            echo "⚠️ Existing postgres StatefulSet found. Handling StatefulSet update..."
            
            # Get PVCs associated with the StatefulSet to ensure we don't lose data
            PVC_LIST=$(kubectl get pvc -n posey -l app=postgres -o jsonpath='{.items[*].metadata.name}')
            echo "Found Postgres PVCs: $PVC_LIST"
            
            # Delete the StatefulSet but keep the PVCs
            echo "Deleting postgres StatefulSet while preserving PVCs..."
            kubectl delete statefulset postgres -n posey --cascade=orphan
            
            # Wait for StatefulSet deletion to complete
            echo "Waiting for postgres StatefulSet deletion to complete..."
            kubectl wait --for=delete statefulset/postgres -n posey --timeout=120s || echo "Timed out waiting for postgres deletion, continuing anyway..."
          fi
          
          # Handle Couchbase StatefulSet
          if kubectl get statefulset couchbase -n posey &>/dev/null; then
            echo "⚠️ Existing couchbase StatefulSet found. Handling StatefulSet update..."
            
            # Get PVCs associated with the StatefulSet to ensure we don't lose data
            PVC_LIST=$(kubectl get pvc -n posey -l app=couchbase -o jsonpath='{.items[*].metadata.name}')
            echo "Found Couchbase PVCs: $PVC_LIST"
            
            # Delete the StatefulSet but keep the PVCs
            echo "Deleting couchbase StatefulSet while preserving PVCs..."
            kubectl delete statefulset couchbase -n posey --cascade=orphan
            
            # Wait for StatefulSet deletion to complete
            echo "Waiting for couchbase StatefulSet deletion to complete..."
            kubectl wait --for=delete statefulset/couchbase -n posey --timeout=120s || echo "Timed out waiting for couchbase deletion, continuing anyway..."
          fi
          
          # Check for Vector.db/Qdrant StatefulSet too
          if kubectl get statefulset qdrant -n posey &>/dev/null; then
            echo "⚠️ Existing qdrant StatefulSet found. Handling StatefulSet update..."
            
            # Get PVCs associated with the StatefulSet to ensure we don't lose data
            PVC_LIST=$(kubectl get pvc -n posey -l app=qdrant -o jsonpath='{.items[*].metadata.name}')
            echo "Found Qdrant PVCs: $PVC_LIST"
            
            # Delete the StatefulSet but keep the PVCs
            echo "Deleting qdrant StatefulSet while preserving PVCs..."
            kubectl delete statefulset qdrant -n posey --cascade=orphan
            
            # Wait for StatefulSet deletion to complete
            echo "Waiting for qdrant StatefulSet deletion to complete..."
            kubectl wait --for=delete statefulset/qdrant -n posey --timeout=120s || echo "Timed out waiting for qdrant deletion, continuing anyway..."
          fi
          
          # Apply deployment
          yarn deploy
        
      - name: Verify deployment
        run: |
          kubectl get pods -n posey
          
      - name: Notify on success
        if: success()
        run: |
          echo "✅ Data services deployment successful"
          
      - name: Notify on failure
        if: failure()
        run: |
          echo "❌ Data services deployment failed" 
  build-and-deploy-core-services:
    name: Build and Deploy Core Services
    runs-on: ubuntu-latest-4-cores
    environment: ${{ github.event.inputs.environment || (github.ref_name == 'main' && 'production' || 'staging') }}
    
    env:
      DOCTL_VERSION: 1.92.1
      KUBE_CLUSTER_ID: ${{ (github.event.inputs.environment == 'production' || github.ref_name == 'main') && secrets.DO_KUBERNETES_CLUSTER_ID || secrets.DO_KUBERNETES_CLUSTER_ID_STAGING }}
      SUPERTOKENS_API_KEY: ${{ secrets.SUPERTOKENS_API_KEY }}
      SUPERTOKENS_DASHBOARD_PASSWORD: ${{ secrets.SUPERTOKENS_DASHBOARD_PASSWORD }}
      GRAPH_API_SECRET: ${{ secrets.GRAPH_API_SECRET }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
      POSTGRES_DB_POSEY: ${{ secrets.POSTGRES_DB_POSEY }}
      POSTGRES_HOST: ${{ secrets.POSTGRES_HOST || 'posey-postgres' }}
      COUCHBASE_USER: ${{ secrets.COUCHBASE_USER }}
      COUCHBASE_PASSWORD: ${{ secrets.COUCHBASE_PASSWORD }}
      COUCHBASE_BUCKET: ${{ secrets.COUCHBASE_BUCKET }}
      ENVIRONMENT: ${{ github.event.inputs.environment || (github.ref_name == 'main' && 'production' || 'staging') }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Enable Corepack
        run: |
          corepack enable
          yarn --version

      - name: Install dependencies
        run: |
          cd services
          yarn install

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}

      - name: Login to DigitalOcean Container Registry
        run: |
          doctl registry login --expiry-seconds 3600
        
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Save DigitalOcean kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ env.KUBE_CLUSTER_ID }}
        
      - name: Create .env file
        run: |
          cd services
          # Create .env file with required variables
          cat > .env << EOF
          # Environment
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          DOCKER_REGISTRY=registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}
          
          # Database Connections
          POSTGRES_USER=${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
          POSTGRES_PORT=${{ env.POSTGRES_PORT }}
          POSTGRES_DB_POSEY=${{ env.POSTGRES_DB_POSEY }}
          POSTGRES_HOST=${{ env.POSTGRES_HOST }}
          COUCHBASE_USER=${{ env.COUCHBASE_USER }}
          COUCHBASE_PASSWORD=${{ env.COUCHBASE_PASSWORD }}
          COUCHBASE_BUCKET=${{ env.COUCHBASE_BUCKET }}
          
          # Auth
          SUPERTOKENS_API_KEY=${{ env.SUPERTOKENS_API_KEY }}
          SUPERTOKENS_DASHBOARD_PASSWORD=${{ env.SUPERTOKENS_DASHBOARD_PASSWORD }}
          GRAPH_API_SECRET=${{ env.GRAPH_API_SECRET }}
          
          # Add any additional environment variables needed
          ${{ secrets.ADDITIONAL_ENV_VARS }}
          EOF
          
          echo "Created .env file for services deployment"

      - name: Free disk space
        run: |
          echo "Checking available disk space before cleanup:"
          df -h
          
          # Remove unnecessary large directories
          echo "Removing unnecessary large directories..."
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
          
          # Clean Docker cache
          echo "Cleaning Docker cache..."
          docker system prune -af
          
          echo "Available disk space after cleanup:"
          df -h
        
      - name: Build Docker images
        run: |
          cd services
          if [[ -n "${{ github.event.inputs.service }}" ]]; then
            echo "Building specific service: ${{ github.event.inputs.service }}"
            yarn build:local -- --service ${{ github.event.inputs.service }}
          else
            echo "Building all services"
            yarn build:local
          fi
        
      - name: Tag and push Docker images
        run: |
          # Get the short SHA of the commit
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          echo "Using commit SHA: ${SHORT_SHA}"
          
          cd services
          
          # Get all services images
          SERVICES_IMAGES=$(docker images | grep 'posey' | grep -v 'postgres\|couchbase\|qdrant\|vector' | awk '{print $1}')
          
          if [ -z "$SERVICES_IMAGES" ]; then
            echo "No service images found to push"
            docker images
            exit 1
          fi

          echo "Found service images: $SERVICES_IMAGES"
          
          # Refresh registry login just before pushing
          doctl registry login --expiry-seconds 3600
          
          # Tag and push all service images
          for IMAGE in $SERVICES_IMAGES; do
            if [[ -n "${{ github.event.inputs.service }}" && ! "$IMAGE" =~ "${{ github.event.inputs.service }}" ]]; then
              echo "Skipping $IMAGE (not the specified service)"
              continue
            fi
            
            echo "Tagging and pushing $IMAGE"

            # Extract the image name without registry prefix if present
            IMAGE_NAME=$(echo $IMAGE | sed 's|^.*/||')
            echo "Extracted image name: $IMAGE_NAME"
            
            # Use only the image name for tagging with registry from secrets
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${SHORT_SHA}
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${{ env.ENVIRONMENT }}
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:latest
            
            echo "Tagged images. Pushing to registry..."
            
            # Push tags
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${SHORT_SHA}
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${{ env.ENVIRONMENT }}
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:latest
          done
        
      - name: Deploy to Kubernetes
        run: |
          cd services
          
          # Set the namespace based on environment
          NAMESPACE="posey"
          if [ "${{ env.ENVIRONMENT }}" == "staging" ]; then
            NAMESPACE="posey-staging"
            # Create namespace if it doesn't exist
            kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          fi
          
          # Set namespace for deployment
          export KUBE_NAMESPACE=$NAMESPACE
          
          if [[ -n "${{ github.event.inputs.service }}" ]]; then
            echo "Deploying specific service: ${{ github.event.inputs.service }} to namespace $NAMESPACE"
            yarn deploy:local -- --service ${{ github.event.inputs.service }} ${{ env.ENVIRONMENT == 'staging' && '--staging' || '' }}
          else
            echo "Deploying all services to namespace $NAMESPACE"
            yarn deploy:local ${{ env.ENVIRONMENT == 'staging' && '--staging' || '' }}
          fi
        
      - name: Verify deployment
        run: |
          NAMESPACE="posey"
          if [ "${{ env.ENVIRONMENT }}" == "staging" ]; then
            NAMESPACE="posey-staging"
          fi
          
          echo "Checking pod status in namespace $NAMESPACE:"
          kubectl get pods -n $NAMESPACE -l part-of=posey-platform
          
      - name: Display service URLs
        if: success()
        run: |
          NAMESPACE="posey"
          if [ "${{ env.ENVIRONMENT }}" == "staging" ]; then
            NAMESPACE="posey-staging"
          fi
          
          echo "✅ Services deployed successfully to ${{ env.ENVIRONMENT }} environment"
          echo "Services are available at:"
          
          if [ "${{ env.ENVIRONMENT }}" == "production" ]; then
            echo "- Auth API: https://auth.posey.ai"
            echo "- MCP API: https://mcp.posey.ai"
            echo "- Voyager API: https://voyager.posey.ai"
            echo "- Agents API: https://agents.posey.ai"
          else
            echo "- Auth API: https://auth.staging.posey.ai"
            echo "- MCP API: https://mcp.staging.posey.ai"
            echo "- Voyager API: https://voyager.staging.posey.ai"
            echo "- Agents API: https://agents.staging.posey.ai"
          fi
          
          echo ""
          echo "You can check the status of your pods with:"
          echo "kubectl get pods -n $NAMESPACE -l part-of=posey-platform"
          
      - name: Notify on failure
        if: failure()
        run: |
          echo "❌ Services deployment to ${{ env.ENVIRONMENT }} failed" 