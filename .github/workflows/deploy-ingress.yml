name: Deploy Ingress Configuration

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - staging
          - local
      action:
        description: 'Action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - dryrun
      update_dns:
        description: 'Update DNS records'
        required: false
        default: true
        type: boolean
      domain:
        description: 'Base domain name (e.g., posey.ai)'
        required: false
        default: 'posey.ai'
        type: string

env:
  CLUSTER_ID: ${{ (github.event.inputs.environment == 'staging') && secrets.DO_KUBERNETES_CLUSTER_ID_STAGING || secrets.DO_KUBERNETES_CLUSTER_ID }}
  DOMAIN: ${{ github.event.inputs.domain || 'posey.ai' }}

jobs:
  deploy-ingress:
    name: Deploy Ingress Configuration
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}
          
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Save DigitalOcean kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ env.CLUSTER_ID }}
        
      - name: Install cert-manager (for prod environment)
        if: github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'staging'
        run: |
          echo "Installing cert-manager for TLS support..."
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
          
          # Wait for cert-manager to be ready
          kubectl wait --namespace cert-manager \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=180s || echo "Cert-manager might not be fully ready yet"
      
      - name: Install NGINX Ingress Controller
        run: |
          echo "Installing NGINX Ingress Controller..."
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/do/deploy.yaml
          
          # Wait for NGINX Ingress to be ready
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=180s || echo "NGINX controller might not be fully ready yet"
      
      - name: Configure Let's Encrypt email
        if: github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'staging'
        run: |
          # Use a proper email address for LetsEncrypt notifications
          sed -i "s/YOUR_EMAIL@posey.ai/${{ secrets.LETSENCRYPT_EMAIL || 'admin@posey.ai' }}/g" k8s/ingress/overlays/${{ github.event.inputs.environment }}/letsencrypt-issuer.yaml
      
      - name: Convert LoadBalancer services to ClusterIP
        if: github.event.inputs.action == 'apply'
        run: |
          NAMESPACE="posey"
          if [ "${{ github.event.inputs.environment }}" == "staging" ]; then
            NAMESPACE="posey-staging"
          fi
          
          echo "Converting LoadBalancer services to ClusterIP in namespace $NAMESPACE..."
          kubectl get svc -n $NAMESPACE -o name | grep -v "kubernetes" | xargs -I {} kubectl patch {} -n $NAMESPACE -p '{"spec": {"type": "ClusterIP"}}' || echo "No services to patch"
      
      - name: Apply Ingress Configuration
        if: github.event.inputs.action == 'apply'
        run: |
          echo "Applying ingress configuration for ${{ github.event.inputs.environment }} environment..."
          
          # Ensure the overlay directory exists, or use base as fallback
          if [ ! -d "k8s/ingress/overlays/${{ github.event.inputs.environment }}" ]; then
            if [ "${{ github.event.inputs.environment }}" == "staging" ]; then
              echo "Creating staging overlay based on prod..."
              mkdir -p k8s/ingress/overlays/staging
              cp -r k8s/ingress/overlays/prod/* k8s/ingress/overlays/staging/
              # Update domain names for staging
              find k8s/ingress/overlays/staging -type f -name "*.yaml" -exec sed -i "s/posey.ai/staging.posey.ai/g" {} \;
            else
              echo "Overlay directory does not exist, applying base configuration."
              kubectl apply -k k8s/ingress/base
              exit 0
            fi
          fi
          
          kubectl apply -k k8s/ingress/overlays/${{ github.event.inputs.environment }}
          
          # If production or staging, apply the LetsEncrypt issuer
          if [ "${{ github.event.inputs.environment }}" == "prod" ] || [ "${{ github.event.inputs.environment }}" == "staging" ]; then
            kubectl apply -f k8s/ingress/overlays/${{ github.event.inputs.environment }}/letsencrypt-issuer.yaml
          fi
      
      - name: Dry Run Ingress Configuration
        if: github.event.inputs.action == 'dryrun'
        run: |
          echo "Dry run of ingress configuration for ${{ github.event.inputs.environment }} environment:"
          kubectl kustomize k8s/ingress/overlays/${{ github.event.inputs.environment }}
      
      - name: Get Ingress IP and Update DNS
        if: github.event.inputs.action == 'apply' && github.event.inputs.update_dns == true && (github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'staging')
        run: |
          echo "Getting ingress controller external IP..."
          
          # Retrieve the external IP of the Load Balancer
          ATTEMPTS=0
          MAX_ATTEMPTS=30
          INTERVAL=10
          
          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            EXTERNAL_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            
            if [ -n "$EXTERNAL_IP" ]; then
              echo "Found external IP: $EXTERNAL_IP"
              break
            fi
            
            echo "Waiting for external IP assignment... (Attempt: $((ATTEMPTS+1))/$MAX_ATTEMPTS)"
            sleep $INTERVAL
            ATTEMPTS=$((ATTEMPTS+1))
          done
          
          if [ -z "$EXTERNAL_IP" ]; then
            echo "Failed to get external IP after $MAX_ATTEMPTS attempts. Aborting DNS update."
            exit 1
          fi
          
          # Set environment-specific domain prefix
          DOMAIN_PREFIX=""
          if [ "${{ github.event.inputs.environment }}" == "staging" ]; then
            DOMAIN_PREFIX="staging."
          fi
          
          BASE_DOMAIN="${DOMAIN_PREFIX}${{ env.DOMAIN }}"
          
          echo "Base domain: $BASE_DOMAIN"
          echo "External IP: $EXTERNAL_IP"
          
          # Define subdomains to configure
          SUBDOMAINS=("auth" "mcp" "voyager" "agents" "cron" "api")
          
          # Check if domain exists in DigitalOcean
          DOMAIN_EXISTS=$(doctl compute domain get ${{ env.DOMAIN }} || echo "not_found")
          
          if [[ "$DOMAIN_EXISTS" == "not_found" ]]; then
            echo "Domain ${{ env.DOMAIN }} not found in DigitalOcean. Creating domain..."
            doctl compute domain create ${{ env.DOMAIN }} --ip-address $EXTERNAL_IP
          fi
          
          # Create/update DNS A records for each subdomain
          for SUBDOMAIN in "${SUBDOMAINS[@]}"; do
            FULL_DOMAIN="${SUBDOMAIN}.${BASE_DOMAIN}"
            echo "Creating/updating DNS A record for $FULL_DOMAIN -> $EXTERNAL_IP"
            
            # Check if record exists
            RECORD_ID=$(doctl compute domain records list ${{ env.DOMAIN }} --format ID,Name,Type,Data --no-header | grep "^[0-9]* *${SUBDOMAIN}.${DOMAIN_PREFIX} *A" | awk '{print $1}')
            
            if [ -n "$RECORD_ID" ]; then
              echo "Updating existing DNS record ID $RECORD_ID for $FULL_DOMAIN"
              doctl compute domain records update ${{ env.DOMAIN }} --record-id $RECORD_ID --record-data $EXTERNAL_IP
            else
              echo "Creating new DNS record for $FULL_DOMAIN"
              doctl compute domain records create ${{ env.DOMAIN }} --record-type A --record-name "${SUBDOMAIN}.${DOMAIN_PREFIX}" --record-data $EXTERNAL_IP --record-ttl 300
            fi
          done
          
          # Also create/update apex domain or staging subdomain
          if [ "${{ github.event.inputs.environment }}" == "prod" ]; then
            # Check if apex record exists
            RECORD_ID=$(doctl compute domain records list ${{ env.DOMAIN }} --format ID,Name,Type,Data --no-header | grep "^[0-9]* *@ *A" | awk '{print $1}')
            
            if [ -n "$RECORD_ID" ]; then
              echo "Updating existing DNS record ID $RECORD_ID for ${{ env.DOMAIN }}"
              doctl compute domain records update ${{ env.DOMAIN }} --record-id $RECORD_ID --record-data $EXTERNAL_IP
            else
              echo "Creating new DNS record for ${{ env.DOMAIN }}"
              doctl compute domain records create ${{ env.DOMAIN }} --record-type A --record-name "@" --record-data $EXTERNAL_IP --record-ttl 300
            fi
          else
            # For staging, create/update the staging. subdomain
            RECORD_ID=$(doctl compute domain records list ${{ env.DOMAIN }} --format ID,Name,Type,Data --no-header | grep "^[0-9]* *staging *A" | awk '{print $1}')
            
            if [ -n "$RECORD_ID" ]; then
              echo "Updating existing DNS record ID $RECORD_ID for staging.${{ env.DOMAIN }}"
              doctl compute domain records update ${{ env.DOMAIN }} --record-id $RECORD_ID --record-data $EXTERNAL_IP
            else
              echo "Creating new DNS record for staging.${{ env.DOMAIN }}"
              doctl compute domain records create ${{ env.DOMAIN }} --record-type A --record-name "staging" --record-data $EXTERNAL_IP --record-ttl 300
            fi
          fi
          
          echo "✅ DNS records updated successfully!"
      
      - name: Display Ingress Service IP
        if: github.event.inputs.action == 'apply'
        run: |
          echo "Ingress controller service information:"
          kubectl get svc -n ingress-nginx
          
          echo ""
          echo "✅ Ingress configuration applied successfully!"
          echo ""
          if [ "${{ github.event.inputs.environment }}" == "prod" ] || [ "${{ github.event.inputs.environment }}" == "staging" ]; then
            echo "DNS Configuration Summary:"
            DOMAIN_PREFIX=""
            if [ "${{ github.event.inputs.environment }}" == "staging" ]; then
              DOMAIN_PREFIX="staging."
              echo "- Base subdomain: staging.${{ env.DOMAIN }}"
            else
              echo "- Base domain: ${{ env.DOMAIN }}"
            fi
            
            # List all configured domains
            echo "Service endpoints:"
            echo "- Auth API: https://auth.${DOMAIN_PREFIX}${{ env.DOMAIN }}"
            echo "- MCP API: https://mcp.${DOMAIN_PREFIX}${{ env.DOMAIN }}"
            echo "- Voyager API: https://voyager.${DOMAIN_PREFIX}${{ env.DOMAIN }}"
            echo "- Agents API: https://agents.${DOMAIN_PREFIX}${{ env.DOMAIN }}"
            echo "- Cron API: https://cron.${DOMAIN_PREFIX}${{ env.DOMAIN }}"
            echo "- API: https://api.${DOMAIN_PREFIX}${{ env.DOMAIN }}"
            
            echo ""
            echo "Certificate status will be available after Let's Encrypt provisioning:"
            echo "kubectl get certificates -n posey"
          else
            echo "For local development testing:"
            echo "1. Add entries to your /etc/hosts file for the .local domains"
            echo "2. Use port-forward to access the ingress controller locally:"
            echo "   kubectl port-forward -n ingress-nginx svc/ingress-nginx-controller 8080:80"
          fi 