name: Deploy Posey Platform

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'PRODUCTION'
        type: choice
        options:
          - PRODUCTION
          - STAGING

env:
  DOCTL_VERSION: 1.92.1
  KUBE_CLUSTER_ID: ${{ secrets.DO_KUBERNETES_CLUSTER_ID }}
  DOMAIN: posey.ai
  SUPERTOKENS_API_KEY: ${{ secrets.SUPERTOKENS_API_KEY }}
  SUPERTOKENS_DASHBOARD_PASSWORD: ${{ secrets.SUPERTOKENS_DASHBOARD_PASSWORD }}
  GRAPH_API_SECRET: ${{ secrets.GRAPH_API_SECRET }}
  POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
  POSTGRES_DB_POSEY: ${{ secrets.POSTGRES_DB_POSEY }}
  POSTGRES_HOST: ${{ secrets.POSTGRES_HOST || 'posey-postgres' }}
  COUCHBASE_USER: ${{ secrets.COUCHBASE_USER }}
  COUCHBASE_PASSWORD: ${{ secrets.COUCHBASE_PASSWORD }}
  COUCHBASE_BUCKET: ${{ secrets.COUCHBASE_BUCKET }}
  ENVIRONMENT: ${{ github.event.inputs.environment || (github.ref_name == 'main' && 'PRODUCTION' || 'STAGING') }}

jobs:
  deploy-ingress:
    name: Deploy Ingress Controller
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref_name == 'main' && 'PRODUCTION' || 'STAGING') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}
          
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Save DigitalOcean kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ env.KUBE_CLUSTER_ID }}
        
      - name: Install cert-manager
        run: |
          echo "Installing cert-manager for TLS support..."
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
          kubectl wait --namespace cert-manager \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=180s || echo "Cert-manager might not be fully ready yet"
      
      - name: Install NGINX Ingress Controller
        run: |
          echo "Installing NGINX Ingress Controller..."
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/do/deploy.yaml
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=180s || echo "NGINX controller might not be fully ready yet"
      
      - name: Configure Let's Encrypt
        run: |
          echo "Configuring Let's Encrypt for ${{ env.ENVIRONMENT }} environment..."
          
          # Create the cert-manager namespace if it doesn't exist
          kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
          
          # Wait for cert-manager webhook to be ready
          kubectl wait --namespace cert-manager \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=webhook \
            --timeout=180s || echo "Cert-manager webhook might not be fully ready yet"
          
          # Update email in the issuer configuration
          if [ -f "k8s/ingress/overlays/${{ env.ENVIRONMENT }}/letsencrypt-issuer.yaml" ]; then
            echo "Updating Let's Encrypt email in issuer configuration..."
            sed -i "s/YOUR_EMAIL@posey.ai/${{ secrets.LETSENCRYPT_EMAIL }}/g" k8s/ingress/overlays/${{ env.ENVIRONMENT }}/letsencrypt-issuer.yaml
            
            # Apply the issuer configuration
            kubectl apply -f k8s/ingress/overlays/${{ env.ENVIRONMENT }}/letsencrypt-issuer.yaml
            
            # Wait for the issuer to be ready
            if [ "${{ env.ENVIRONMENT }}" == "PRODUCTION" ]; then
              kubectl wait --for=condition=ready clusterissuer/letsencrypt-prod --timeout=60s || echo "ClusterIssuer might not be fully ready yet"
            else
              kubectl wait --for=condition=ready clusterissuer/letsencrypt-staging --timeout=60s || echo "ClusterIssuer might not be fully ready yet"
            fi
          else
            echo "⚠️ Let's Encrypt issuer configuration not found at k8s/ingress/overlays/${{ env.ENVIRONMENT }}/letsencrypt-issuer.yaml"
            exit 1
          fi
      
      - name: Apply Ingress Configuration
        run: |
          echo "Applying ingress configuration for ${{ env.ENVIRONMENT }} environment..."
          kubectl apply -k k8s/ingress/overlays/${{ env.ENVIRONMENT }}
      
      - name: Get Ingress IP and Update DNS
        run: |
          echo "Getting ingress controller external IP..."
          ATTEMPTS=0
          MAX_ATTEMPTS=30
          INTERVAL=10
          
          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            EXTERNAL_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EXTERNAL_IP" ]; then
              echo "Found external IP: $EXTERNAL_IP"
              break
            fi
            echo "Waiting for external IP assignment... (Attempt: $((ATTEMPTS+1))/$MAX_ATTEMPTS)"
            sleep $INTERVAL
            ATTEMPTS=$((ATTEMPTS+1))
          done
          
          if [ -z "$EXTERNAL_IP" ]; then
            echo "Failed to get external IP after $MAX_ATTEMPTS attempts"
            exit 1
          fi
          
          # Set environment-specific domain prefix
          DOMAIN_PREFIX=""
          if [ "${{ env.ENVIRONMENT }}" == "STAGING" ]; then
            DOMAIN_PREFIX="staging."
          fi
          
          BASE_DOMAIN="${DOMAIN_PREFIX}${{ env.DOMAIN }}"
          
          # Define subdomains to configure
          SUBDOMAINS=("auth" "mcp" "voyager" "agents" "cron" "api")
          
          # Check if domain exists in DigitalOcean
          DOMAIN_EXISTS=$(doctl compute domain get ${{ env.DOMAIN }} || echo "not_found")
          if [[ "$DOMAIN_EXISTS" == "not_found" ]]; then
            echo "Domain ${{ env.DOMAIN }} not found in DigitalOcean. Creating domain..."
            doctl compute domain create ${{ env.DOMAIN }} --ip-address $EXTERNAL_IP
          fi
          
          # Create/update DNS A records for each subdomain
          for SUBDOMAIN in "${SUBDOMAINS[@]}"; do
            FULL_DOMAIN="${SUBDOMAIN}.${BASE_DOMAIN}"
            echo "Creating/updating DNS A record for $FULL_DOMAIN -> $EXTERNAL_IP"
            
            RECORD_ID=$(doctl compute domain records list ${{ env.DOMAIN }} --format ID,Name,Type,Data --no-header | grep "^[0-9]* *${SUBDOMAIN}.${DOMAIN_PREFIX} *A" | awk '{print $1}')
            
            if [ -n "$RECORD_ID" ]; then
              echo "Updating existing DNS record ID $RECORD_ID for $FULL_DOMAIN"
              doctl compute domain records update ${{ env.DOMAIN }} --record-id $RECORD_ID --record-data $EXTERNAL_IP
            else
              echo "Creating new DNS record for $FULL_DOMAIN"
              doctl compute domain records create ${{ env.DOMAIN }} --record-type A --record-name "${SUBDOMAIN}.${DOMAIN_PREFIX}" --record-data $EXTERNAL_IP --record-ttl 300
            fi
          done
          
          # Create/update apex domain or staging subdomain
          if [ "${{ env.ENVIRONMENT }}" == "PRODUCTION" ]; then
            RECORD_ID=$(doctl compute domain records list ${{ env.DOMAIN }} --format ID,Name,Type,Data --no-header | grep "^[0-9]* *@ *A" | awk '{print $1}')
            if [ -n "$RECORD_ID" ]; then
              doctl compute domain records update ${{ env.DOMAIN }} --record-id $RECORD_ID --record-data $EXTERNAL_IP
            else
              doctl compute domain records create ${{ env.DOMAIN }} --record-type A --record-name "@" --record-data $EXTERNAL_IP --record-ttl 300
            fi
          else
            RECORD_ID=$(doctl compute domain records list ${{ env.DOMAIN }} --format ID,Name,Type,Data --no-header | grep "^[0-9]* *staging *A" | awk '{print $1}')
            if [ -n "$RECORD_ID" ]; then
              doctl compute domain records update ${{ env.DOMAIN }} --record-id $RECORD_ID --record-data $EXTERNAL_IP
            else
              doctl compute domain records create ${{ env.DOMAIN }} --record-type A --record-name "staging" --record-data $EXTERNAL_IP --record-ttl 300
            fi
          fi

  deploy-data:
    name: Deploy Data Services
    needs: deploy-ingress
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || (github.ref_name == 'main' && 'PRODUCTION' || 'STAGING') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Enable Corepack
        run: |
          corepack enable
          yarn --version

      - name: Install dependencies
        run: |
          cd data
          yarn install

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}

      - name: Login to DigitalOcean Container Registry
        run: |
          doctl registry login --expiry-seconds 3600
        
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Save DigitalOcean kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ env.KUBE_CLUSTER_ID }}
        
      - name: Create .env file
        run: |
          cd data
          cat > .env << EOF
          POSTGRES_USER=${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
          POSTGRES_PORT=${{ env.POSTGRES_PORT }}
          POSTGRES_DB_POSEY=${{ env.POSTGRES_DB_POSEY }}
          POSTGRES_HOST=${{ env.POSTGRES_HOST }}
          COUCHBASE_USER=${{ env.COUCHBASE_USER }}
          COUCHBASE_PASSWORD=${{ env.COUCHBASE_PASSWORD }}
          COUCHBASE_BUCKET=${{ env.COUCHBASE_BUCKET }}
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          DOCKER_REGISTRY=registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}
          EOF
          
      - name: Build Docker images
        run: |
          cd data
          yarn build
          
      - name: Tag and push Docker images
        run: |
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          cd data
          
          POSEY_IMAGES=$(docker images | grep 'posey' | awk '{print $1}')
          if [ -z "$POSEY_IMAGES" ]; then
            echo "No posey images found to push"
            exit 1
          fi

          echo "Found posey images: $POSEY_IMAGES"
          doctl registry login --expiry-seconds 3600
          
          for IMAGE in $POSEY_IMAGES; do
            IMAGE_NAME=$(echo $IMAGE | sed 's|registry.digitalocean.com/posey/||')
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${SHORT_SHA}
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:latest
            
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${SHORT_SHA}
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:latest
          done
        
      - name: Deploy to Kubernetes
        run: |
          cd data
          
          # Handle existing StatefulSets
          for SERVICE in postgres couchbase qdrant; do
            if kubectl get statefulset $SERVICE -n posey &>/dev/null; then
              echo "⚠️ Existing $SERVICE StatefulSet found. Handling StatefulSet update..."
              PVC_LIST=$(kubectl get pvc -n posey -l app=$SERVICE -o jsonpath='{.items[*].metadata.name}')
              echo "Found $SERVICE PVCs: $PVC_LIST"
              kubectl delete statefulset $SERVICE -n posey --cascade=orphan
              kubectl wait --for=delete statefulset/$SERVICE -n posey --timeout=120s || echo "Timed out waiting for $SERVICE deletion, continuing anyway..."
            fi
          done
          
          yarn deploy
        
      - name: Verify deployment
        run: |
          kubectl get pods -n posey

  deploy-services:
    name: Deploy Application Services
    needs: deploy-data
    runs-on: ubuntu-latest-4-cores
    environment: ${{ github.event.inputs.environment || (github.ref_name == 'main' && 'PRODUCTION' || 'STAGING') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Enable Corepack
        run: |
          corepack enable
          yarn --version

      - name: Install dependencies
        run: |
          cd services
          yarn install

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}

      - name: Login to DigitalOcean Container Registry
        run: |
          doctl registry login --expiry-seconds 3600
        
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: Save DigitalOcean kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ env.KUBE_CLUSTER_ID }}
        
      - name: Create .env file
        run: |
          cd services
          cat > .env << EOF
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          DOCKER_REGISTRY=registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}
          POSTGRES_USER=${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
          POSTGRES_PORT=${{ env.POSTGRES_PORT }}
          POSTGRES_DB_POSEY=${{ env.POSTGRES_DB_POSEY }}
          POSTGRES_HOST=${{ env.POSTGRES_HOST }}
          COUCHBASE_USER=${{ env.COUCHBASE_USER }}
          COUCHBASE_PASSWORD=${{ env.COUCHBASE_PASSWORD }}
          COUCHBASE_BUCKET=${{ env.COUCHBASE_BUCKET }}
          SUPERTOKENS_API_KEY=${{ env.SUPERTOKENS_API_KEY }}
          SUPERTOKENS_DASHBOARD_PASSWORD=${{ env.SUPERTOKENS_DASHBOARD_PASSWORD }}
          GRAPH_API_SECRET=${{ env.GRAPH_API_SECRET }}
          ${{ secrets.ADDITIONAL_ENV_VARS }}
          EOF
          
      - name: Free disk space
        run: |
          echo "Checking available disk space before cleanup:"
          df -h
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
          docker system prune -af
          echo "Available disk space after cleanup:"
          df -h
        
      - name: Build Docker images
        run: |
          cd services
          yarn build:local
        
      - name: Tag and push Docker images
        run: |
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          cd services
          
          SERVICES_IMAGES=$(docker images | grep 'posey' | grep -v 'postgres\|couchbase\|qdrant\|vector' | awk '{print $1}')
          if [ -z "$SERVICES_IMAGES" ]; then
            echo "No service images found to push"
            docker images
            exit 1
          fi

          echo "Found service images: $SERVICES_IMAGES"
          doctl registry login --expiry-seconds 3600
          
          for IMAGE in $SERVICES_IMAGES; do
            IMAGE_NAME=$(echo $IMAGE | sed 's|^.*/||')
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${SHORT_SHA}
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${{ env.ENVIRONMENT }}
            docker tag $IMAGE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:latest
            
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${SHORT_SHA}
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:${{ env.ENVIRONMENT }}
            docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${IMAGE_NAME}:latest
          done
        
      - name: Deploy to Kubernetes
        run: |
          cd services
          
          NAMESPACE="posey"
          if [ "${{ env.ENVIRONMENT }}" == "STAGING" ]; then
            NAMESPACE="posey-staging"
            kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          fi
          
          export KUBE_NAMESPACE=$NAMESPACE
          yarn deploy:local ${{ env.ENVIRONMENT == 'STAGING' && '--staging' || '' }}
        
      - name: Verify deployment
        run: |
          NAMESPACE="posey"
          if [ "${{ env.ENVIRONMENT }}" == "STAGING" ]; then
            NAMESPACE="posey-staging"
          fi
          
          echo "Checking pod status in namespace $NAMESPACE:"
          kubectl get pods -n $NAMESPACE -l part-of=posey-platform
          
      - name: Display service URLs
        if: success()
        run: |
          NAMESPACE="posey"
          if [ "${{ env.ENVIRONMENT }}" == "STAGING" ]; then
            NAMESPACE="posey-staging"
          fi
          
          echo "✅ Services deployed successfully to ${{ env.ENVIRONMENT }} environment"
          echo "Services are available at:"
          
          if [ "${{ env.ENVIRONMENT }}" == "PRODUCTION" ]; then
            echo "- Auth API: https://auth.posey.ai"
            echo "- MCP API: https://mcp.posey.ai"
            echo "- Voyager API: https://voyager.posey.ai"
            echo "- Agents API: https://agents.posey.ai"
          else
            echo "- Auth API: https://auth.staging.posey.ai"
            echo "- MCP API: https://mcp.staging.posey.ai"
            echo "- Voyager API: https://voyager.staging.posey.ai"
            echo "- Agents API: https://agents.staging.posey.ai"
          fi
          
          echo ""
          echo "You can check the status of your pods with:"
          echo "kubectl get pods -n $NAMESPACE -l part-of=posey-platform" 