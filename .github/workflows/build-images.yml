name: Build Posey Docker Images

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      service:
        description: Posey build'
        required: false
        type: string

env:
  DOCTL_VERSION: 1.92.1
  ENVIRONMENT: ${{ github.ref_name == 'main' && 'PRODUCTION' || 'STAGING' }}

jobs:
  build-posey:
    name: Build Posey (all)
    runs-on:
      group: posey-runners
    environment: PRODUCTION
    steps:
      - name: Debug runner information
        run: |
          echo "Runner name: $RUNNER_NAME"
          echo "Runner OS: $RUNNER_OS"
          echo "GitHub workspace: $GITHUB_WORKSPACE"
          echo "GitHub repository: $GITHUB_REPOSITORY"
          
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Enable Corepack
        run: |
          corepack enable
          yarn --version

      - name: Install dependencies
        run: |
          cd services
          yarn install

      - name: Debug Secret Availability
        run: |
          echo "Checking if DO_API_TOKEN secret is available..."
          if [ -n "${{ secrets.DO_API_TOKEN }}" ]; then
            echo "DO_API_TOKEN is available (value hidden for security)"
          else
            echo "DO_API_TOKEN appears to be empty or not available!"
          fi

      - name: Install doctl manually
        run: |
          # Download and install doctl
          cd /tmp
          curl -sL https://github.com/digitalocean/doctl/releases/download/v${{ env.DOCTL_VERSION }}/doctl-${{ env.DOCTL_VERSION }}-linux-arm64.tar.gz | tar -xzv
          sudo mv doctl /usr/local/bin/
          
          # Verify installation
          doctl version
          
          # Configure authentication
          doctl auth init -t ${{ secrets.DO_API_TOKEN }}

      - name: Login to DigitalOcean Container Registry
        run: |
          doctl registry login --expiry-seconds 3600
          
      - name: Free up disk space
        run: |
          echo "Disk space before cleanup:"
          df -h
          
          # Remove unnecessary large directories
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          
          # Clean up apt cache
          sudo apt-get clean
          sudo apt-get autoremove -y
          
          # Clean Docker
          docker system prune -af --volumes
          
          echo "Disk space after cleanup:"
          df -h
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          version: v0.12.0
          
      - name: Create disk cleanup script
        run: |
          cat > /tmp/cleanup.sh << 'EOF'
          #!/bin/bash
          # Check if disk space is below threshold (15% free)
          DISK_FREE=$(df / | grep / | awk '{ print $4 }')
          THRESHOLD=$(($(df / | grep / | awk '{ print $2 }') * 15 / 100))
          
          if [ "$DISK_FREE" -lt "$THRESHOLD" ]; then
            echo "Disk space running low, cleaning up..."
            docker system prune -af --volumes
          fi
          EOF
          chmod +x /tmp/cleanup.sh
          
      - name: Prepare buildx cache directory
        run: |
          mkdir -p /tmp/.buildx-cache
          echo "{}" > /tmp/.buildx-cache/index.json
          echo "Created buildx cache directory with empty index"
          
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
            
      - name: Set up Python dependencies cache
        id: python-cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
            
      - name: Cache Python wheels
        id: wheel-cache
        uses: actions/cache@v3
        with:
          path: services/agents/.wheels
          key: ${{ runner.os }}-wheels-${{ hashFiles('services/agents/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-wheels-

      - name: Setup model cache directories
        run: |
          mkdir -p ~/.cache/huggingface
          mkdir -p ~/.cache/torch
          mkdir -p services/agents/.wheels
          
      - name: Cache HuggingFace models
        id: hf-cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/huggingface
          key: ${{ runner.os }}-huggingface-${{ hashFiles('services/agents/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-huggingface-
            
      - name: Cache PyTorch models
        id: torch-cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/torch
          key: ${{ runner.os }}-torch-${{ hashFiles('services/agents/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-torch-
      
      - name: Build Docker images
        run: |
          cd services
          
          # Set up periodic cleanup
          (while true; do /tmp/cleanup.sh; sleep 60; done) &
          CLEANUP_PID=$!
          
          # Build services one at a time
          SERVICES="auth supertokens voyager mcp agents cron"
          
          # If service input is specified, only build that one
          if [[ -n "${{ github.event.inputs.service }}" ]]; then
            SERVICES="${{ github.event.inputs.service }}"
          fi
          
          for SERVICE in $SERVICES; do
            echo "Building $SERVICE..."
            
            # Use direct Docker build for all services (bypassing yarn build completely)
            echo "Building $SERVICE directly with Docker..."
            DOCKER_BUILDKIT=1 BUILDKIT_PROGRESS=plain docker build \
              --build-arg BUILDKIT_INLINE_CACHE=1 \
              --cache-from registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:latest \
              --cache-from registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${{ env.ENVIRONMENT }} \
              --platform linux/arm64 \
              -t ${SERVICE} \
              -f ${SERVICE}/Dockerfile \
              ./${SERVICE} || {
                echo "⚠️ Warning: Error building $SERVICE with direct Docker command, but continuing"
              }
            
            # Run cleanup after each build
            /tmp/cleanup.sh
          done
          
          # Kill cleanup process
          kill $CLEANUP_PID || true
          
      - name: Tag and push Docker images
        run: |
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          cd services
          
          # Get list of services directly from the SERVICES variable
          SERVICES="auth supertokens voyager mcp agents cron"
          
          # Override if service parameter is provided
          if [[ -n "${{ github.event.inputs.service }}" ]]; then
            SERVICES="${{ github.event.inputs.service }}"
          fi
          
          # Refresh auth before pushing
          doctl registry login --expiry-seconds 3600
          
          # Tag and push each service's image
          for SERVICE in $SERVICES; do
            echo "Processing image for $SERVICE..."
            
            # Check if the image exists
            if docker images $SERVICE | grep -q "$SERVICE"; then
              echo "Image found for $SERVICE, tagging and pushing..."
              
              # Create tags
              docker tag $SERVICE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${SHORT_SHA}
              docker tag $SERVICE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${{ env.ENVIRONMENT }}
              docker tag $SERVICE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:latest
              
              # Push each tag
              for TAG in ${SHORT_SHA} ${{ env.ENVIRONMENT }} latest; do
                echo "Pushing ${SERVICE}:${TAG}..."
                docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${TAG}
              done
            else
              echo "Warning: No image found for $SERVICE, skipping"
              docker images
            fi
          done
          
      - name: Configure Git for manifest updates
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
          
      - name: Update Kubernetes manifests in monorepo
        run: |
          # Get the short SHA for image tags
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          
          # Install yq if needed
          sudo curl -sL https://github.com/mikefarah/yq/releases/download/v4.34.1/yq_linux_arm64 -o /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq
          
          # Update image tags in kustomization files for each service
          SERVICES="auth supertokens voyager mcp agents cron"
          if [[ -n "${{ github.event.inputs.service }}" ]]; then
            SERVICES="${{ github.event.inputs.service }}"
          fi
          
          UPDATED_FILES=0

          # Check k8s directory first
          for SERVICE in $SERVICES; do
            echo "Checking k8s directory for $SERVICE..."
            
            # Check if service has k8s directory
            if [ -d "k8s/$SERVICE" ]; then
              # Try to update kustomization.yaml if it exists
              if [ -f "k8s/$SERVICE/kustomization.yaml" ]; then
                # Check if it has an images field before trying to update
                if yq eval '.images' "k8s/$SERVICE/kustomization.yaml" | grep -q "."; then
                  yq eval ".images[0].newTag = \"${SHORT_SHA}\"" -i "k8s/$SERVICE/kustomization.yaml"
                  echo "Updated image tag in k8s/$SERVICE/kustomization.yaml"
                  git add "k8s/$SERVICE/kustomization.yaml"
                  UPDATED_FILES=$((UPDATED_FILES + 1))
                else
                  echo "No images field in k8s/$SERVICE/kustomization.yaml, skipping"
                fi
              else
                echo "No kustomization.yaml found for $SERVICE in k8s"
                
                # Try to update deployment.yaml directly
                if [ -f "k8s/$SERVICE/deployment.yaml" ]; then
                  # Check if the file contains image references we need to update
                  if grep -q "image: registry.digitalocean.com" "k8s/$SERVICE/deployment.yaml"; then
                    sed -i "s|registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:[^[:space:]]*|registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${SHORT_SHA}|g" "k8s/$SERVICE/deployment.yaml"
                    echo "Updated image in k8s/$SERVICE/deployment.yaml"
                    git add "k8s/$SERVICE/deployment.yaml"
                    UPDATED_FILES=$((UPDATED_FILES + 1))
                  fi
                fi
              fi
            else
              echo "No k8s/$SERVICE directory found"
            fi
          done

          # Check services directory for k8s files
          for SERVICE in $SERVICES; do
            echo "Checking services directory for $SERVICE..."
            
            # Check if service has a k8s directory within services
            if [ -d "services/$SERVICE/k8s" ]; then
              echo "Found k8s directory in services/$SERVICE"
              
              # Try to update kustomization.yaml if it exists
              if [ -f "services/$SERVICE/k8s/kustomization.yaml" ]; then
                # Check if it has an images field before trying to update
                if yq eval '.images' "services/$SERVICE/k8s/kustomization.yaml" | grep -q "."; then
                  yq eval ".images[0].newTag = \"${SHORT_SHA}\"" -i "services/$SERVICE/k8s/kustomization.yaml"
                  echo "Updated image tag in services/$SERVICE/k8s/kustomization.yaml"
                  git add "services/$SERVICE/k8s/kustomization.yaml"
                  UPDATED_FILES=$((UPDATED_FILES + 1))
                fi
              fi
              
              # Check for deployment files
              for DEPLOY_FILE in $(find "services/$SERVICE/k8s" -name "deployment*.yaml"); do
                if grep -q "image: registry.digitalocean.com" "$DEPLOY_FILE"; then
                  sed -i "s|registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:[^[:space:]]*|registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${SHORT_SHA}|g" "$DEPLOY_FILE"
                  echo "Updated image in $DEPLOY_FILE"
                  git add "$DEPLOY_FILE"
                  UPDATED_FILES=$((UPDATED_FILES + 1))
                fi
              done
            fi
          done

          # Check data directory for k8s files
          for SERVICE in $SERVICES postgres vector.db qdrant redis couchbase; do
            echo "Checking data directory for $SERVICE..."
            
            # Check if service has a k8s directory within data
            if [ -d "data/$SERVICE/k8s" ]; then
              echo "Found k8s directory in data/$SERVICE"
              
              # Try to update kustomization.yaml if it exists
              if [ -f "data/$SERVICE/k8s/kustomization.yaml" ]; then
                # Check if it has an images field before trying to update
                if yq eval '.images' "data/$SERVICE/k8s/kustomization.yaml" | grep -q "."; then
                  yq eval ".images[0].newTag = \"${SHORT_SHA}\"" -i "data/$SERVICE/k8s/kustomization.yaml"
                  echo "Updated image tag in data/$SERVICE/k8s/kustomization.yaml"
                  git add "data/$SERVICE/k8s/kustomization.yaml"
                  UPDATED_FILES=$((UPDATED_FILES + 1))
                fi
              fi
              
              # Check for deployment files
              for DEPLOY_FILE in $(find "data/$SERVICE/k8s" -name "deployment*.yaml" -o -name "statefulset*.yaml"); do
                if grep -q "image: registry.digitalocean.com" "$DEPLOY_FILE"; then
                  sed -i "s|registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:[^[:space:]]*|registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${SHORT_SHA}|g" "$DEPLOY_FILE"
                  echo "Updated image in $DEPLOY_FILE"
                  git add "$DEPLOY_FILE"
                  UPDATED_FILES=$((UPDATED_FILES + 1))
                fi
              done
            fi
          done
          
          # Commit and push if there are changes
          if [ "$UPDATED_FILES" -eq 0 ]; then
            echo "No changes to commit"
          else
            git commit -m "Update image tags to ${SHORT_SHA} for ${{ github.event.inputs.service || 'all services' }}"
            git push origin ${{ github.ref_name }}
            echo "Successfully updated $UPDATED_FILES manifest files in repository"
          fi
          
      - name: Configure kubectl for ArgoCD sync
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/arm64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          # Setup kubeconfig for DO Kubernetes
          doctl kubernetes cluster kubeconfig save ${{ secrets.DO_KUBERNETES_CLUSTER_ID }}
          
      - name: Trigger ArgoCD sync
        if: success()
        run: |
          # Install argocd CLI
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-arm64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/
          
          # Get ArgoCD password
          ADMIN_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          
          # Login to ArgoCD
          argocd login ${{ secrets.ARGOCD_SERVER }} --username admin --password "$ADMIN_PASSWORD" --insecure
          
          # Sync all applications or specific service
          if [[ -n "${{ github.event.inputs.service }}" ]]; then
            argocd app sync posey-${{ github.event.inputs.service }} --prune
            argocd app wait posey-${{ github.event.inputs.service }}
          else
            # Use the script if it exists, otherwise sync each app individually
            if [ -f "scripts/argocd-sync-all.sh" ]; then
              chmod +x scripts/argocd-sync-all.sh
              ARGOCD_SERVER=${{ secrets.ARGOCD_SERVER }} ./scripts/argocd-sync-all.sh
            else
              # Sync core applications
              for APP in auth supertokens voyager mcp agents cron; do
                argocd app sync posey-${APP} --prune
              done
              # Wait for sync to complete
              for APP in auth supertokens voyager mcp agents cron; do
                argocd app wait posey-${APP}
              done
            fi
          fi
          
      - name: Create minimal .env file for CI
        run: |
          cat > services/.env << EOF
          # This is an auto-generated .env file for CI deployment
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          
          # DigitalOcean configuration
          DO_REGISTRY_NAME=${{ secrets.DO_REGISTRY_NAME }}
          DO_KUBERNETES_CLUSTER_ID=${{ secrets.DO_KUBERNETES_CLUSTER_ID }}
          
          # Add other CI-specific environment variables here
          NODE_ENV=production
          LOG_LEVEL=info
          
          # Add any additional secrets that deployment scripts need
          QDRANT_HOST=${{ secrets.QDRANT_HOST || 'qdrant.default.svc.cluster.local' }}
          QDRANT_PORT=${{ secrets.QDRANT_PORT || '6333' }}
          POSTGRES_HOST=${{ secrets.POSTGRES_HOST || 'postgres.default.svc.cluster.local' }}
          POSTGRES_PORT=${{ secrets.POSTGRES_PORT || '5432' }}
          REDIS_HOST=${{ secrets.REDIS_HOST || 'redis.default.svc.cluster.local' }}
          REDIS_PORT=${{ secrets.REDIS_PORT || '6379' }}
          EOF
          
          echo "Created CI environment file with necessary deployment variables" 