name: Build Posey System

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      service:
        description: Posey build'
        required: false
        type: string

env:
  DOCTL_VERSION: 1.92.1
  ENVIRONMENT: ${{ github.ref_name == 'main' && 'PRODUCTION' || 'STAGING' }}

jobs:
  build-posey:
    name: Build Posey (all)
    runs-on:
      group: posey-runners
    environment: PRODUCTION
    steps:
      - name: Debug runner information
        run: |
          echo "Runner name: $RUNNER_NAME"
          echo "Runner OS: $RUNNER_OS"
          echo "GitHub workspace: $GITHUB_WORKSPACE"
          echo "GitHub repository: $GITHUB_REPOSITORY"
          
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Enable Corepack
        run: |
          corepack enable
          yarn --version

      - name: Install dependencies
        run: |
          cd services
          yarn install

      - name: Debug Secret Availability
        run: |
          echo "Checking if DO_API_TOKEN secret is available..."
          if [ -n "${{ secrets.DO_API_TOKEN }}" ]; then
            echo "DO_API_TOKEN is available (value hidden for security)"
          else
            echo "DO_API_TOKEN appears to be empty or not available!"
          fi

      - name: Install doctl manually
        run: |
          # Download and install doctl
          cd /tmp
          curl -sL https://github.com/digitalocean/doctl/releases/download/v${{ env.DOCTL_VERSION }}/doctl-${{ env.DOCTL_VERSION }}-linux-arm64.tar.gz | tar -xzv
          sudo mv doctl /usr/local/bin/
          
          # Verify installation
          doctl version
          
          # Configure authentication
          doctl auth init -t ${{ secrets.DO_API_TOKEN }}

      - name: Login to DigitalOcean Container Registry
        run: |
          doctl registry login --expiry-seconds 3600
          
      - name: Free up disk space
        run: |
          echo "Disk space before cleanup:"
          df -h
          
          # Remove unnecessary large directories
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          
          # Clean up apt cache
          sudo apt-get clean
          sudo apt-get autoremove -y
          
          # Clean Docker
          docker system prune -af --volumes
          
          echo "Disk space after cleanup:"
          df -h
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          version: v0.12.0
          
      - name: Create disk cleanup script
        run: |
          cat > /tmp/cleanup.sh << 'EOF'
          #!/bin/bash
          # Check if disk space is below threshold (15% free)
          DISK_FREE=$(df / | grep / | awk '{ print $4 }')
          THRESHOLD=$(($(df / | grep / | awk '{ print $2 }') * 15 / 100))
          
          if [ "$DISK_FREE" -lt "$THRESHOLD" ]; then
            echo "Disk space running low, cleaning up..."
            docker system prune -af --volumes
          fi
          EOF
          chmod +x /tmp/cleanup.sh
          
      - name: Prepare buildx cache directory
        run: |
          mkdir -p /tmp/.buildx-cache
          echo "{}" > /tmp/.buildx-cache/index.json
          echo "Created buildx cache directory with empty index"
          
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
            
      - name: Set up Python dependencies cache
        id: python-cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
            
      - name: Cache Python wheels
        id: wheel-cache
        uses: actions/cache@v3
        with:
          path: services/agents/.wheels
          key: ${{ runner.os }}-wheels-${{ hashFiles('services/agents/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-wheels-

      - name: Setup model cache directories
        run: |
          mkdir -p ~/.cache/huggingface
          mkdir -p ~/.cache/torch
          mkdir -p services/agents/.wheels
          
      - name: Cache HuggingFace models
        id: hf-cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/huggingface
          key: ${{ runner.os }}-huggingface-${{ hashFiles('services/agents/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-huggingface-
            
      - name: Cache PyTorch models
        id: torch-cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/torch
          key: ${{ runner.os }}-torch-${{ hashFiles('services/agents/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-torch-
      
      - name: Build Docker images
        run: |
          cd services
          
          # Set up periodic cleanup
          (while true; do /tmp/cleanup.sh; sleep 60; done) &
          CLEANUP_PID=$!
          
          # Build services one at a time
          SERVICES="auth supertokens voyager mcp agents cron"
          
          # If service input is specified, only build that one
          if [[ -n "${{ github.event.inputs.service }}" ]]; then
            SERVICES="${{ github.event.inputs.service }}"
          fi
          
          for SERVICE in $SERVICES; do
            echo "Building $SERVICE..."
            
            # Use direct Docker build for all services (bypassing yarn build completely)
            echo "Building $SERVICE directly with Docker..."
            DOCKER_BUILDKIT=1 BUILDKIT_PROGRESS=plain docker build \
              --build-arg BUILDKIT_INLINE_CACHE=1 \
              --cache-from registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:latest \
              --cache-from registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${{ env.ENVIRONMENT }} \
              --platform linux/arm64 \
              -t ${SERVICE} \
              -f ${SERVICE}/Dockerfile \
              ./${SERVICE} || {
                echo "⚠️ Warning: Error building $SERVICE with direct Docker command, but continuing"
              }
            
            # Run cleanup after each build
            /tmp/cleanup.sh
          done
          
          # Kill cleanup process
          kill $CLEANUP_PID || true
          
      - name: Tag and push Docker images
        run: |
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          cd services
          
          # Get list of services directly from the SERVICES variable
          SERVICES="auth supertokens voyager mcp agents cron"
          
          # Override if service parameter is provided
          if [[ -n "${{ github.event.inputs.service }}" ]]; then
            SERVICES="${{ github.event.inputs.service }}"
          fi
          
          # Refresh auth before pushing
          doctl registry login --expiry-seconds 3600
          
          # Tag and push each service's image
          for SERVICE in $SERVICES; do
            echo "Processing image for $SERVICE..."
            
            # Check if the image exists
            if docker images $SERVICE | grep -q "$SERVICE"; then
              echo "Image found for $SERVICE, tagging and pushing..."
              
              # Create tags
              docker tag $SERVICE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${SHORT_SHA}
              docker tag $SERVICE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${{ env.ENVIRONMENT }}
              docker tag $SERVICE registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:latest
              
              # Push each tag
              for TAG in ${SHORT_SHA} ${{ env.ENVIRONMENT }} latest; do
                echo "Pushing ${SERVICE}:${TAG}..."
                docker push registry.digitalocean.com/${{ secrets.DO_REGISTRY_NAME }}/${SERVICE}:${TAG}
              done
            else
              echo "Warning: No image found for $SERVICE, skipping"
              docker images
            fi
          done
          
      - name: Configure kubectl for ArgoCD sync
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/arm64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          
          # Setup kubeconfig for DO Kubernetes
          doctl kubernetes cluster kubeconfig save ${{ secrets.DO_KUBERNETES_CLUSTER_ID }}
          
      - name: Trigger ArgoCD sync
        if: success()
        continue-on-error: true  # Make this step optional so the workflow doesn't fail
        timeout-minutes: 5  # Increased timeout
        run: |
          # Install argocd CLI with better error handling
          echo "Downloading ArgoCD CLI..."
          mkdir -p /tmp/argocd-download
          cd /tmp/argocd-download
          
          # Try multiple times with different approaches
          if ! curl -sSL --retry 3 --retry-delay 5 -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-arm64; then
            echo "Direct download failed, trying with wget..."
            wget -q https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-arm64 -O argocd || {
              echo "Error downloading ArgoCD CLI. Trying specific version..."
              curl -sSL --retry 3 -o argocd https://github.com/argoproj/argo-cd/releases/download/v2.8.4/argocd-linux-arm64
            }
          fi
          
          chmod +x argocd
          sudo mv argocd /usr/local/bin/
          
          # Verify installation
          if ! argocd version --client; then
            echo "Failed to install ArgoCD CLI. Exiting."
            exit 1
          fi
          
          # Get ArgoCD password from Kubernetes secret
          ADMIN_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          
          # Login to ArgoCD with correct parameters
          echo "Logging in to ArgoCD at argo.posey.ai with grpc-web..."
          argocd login argo.posey.ai --username admin --password "$ADMIN_PASSWORD" --grpc-web
          
          # Get the short SHA for the latest commit
          SHORT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          echo "Using image tag: ${SHORT_SHA}"
          
          # Register applications if they don't exist
          echo "Checking if applications exist in ArgoCD..."
          
          # Define application details
          SERVICES="auth supertokens voyager mcp agents cron"
          if [[ -n "${{ github.event.inputs.service }}" ]]; then
            SERVICES="${{ github.event.inputs.service }}"
          fi
          
          # Create apps if they don't exist
          for SERVICE in $SERVICES; do
            if ! argocd app get posey-$SERVICE &>/dev/null; then
              echo "Creating application posey-$SERVICE in ArgoCD..."
              argocd app create posey-$SERVICE \
                --repo https://github.com/${{ github.repository }}.git \
                --path services/$SERVICE/k8s \
                --dest-server https://kubernetes.default.svc \
                --dest-namespace ${{ secrets.DO_REGISTRY_NAME }} \
                --directory-recurse || true
            fi
            
            # Sync the application
            echo "Syncing posey-${SERVICE}..."
            argocd app sync posey-$SERVICE --timeout 120 --prune || true
          done
          
          echo "ArgoCD sync completed or attempted for all services"
          
          # Apply configurations directly with kubectl as a fallback
          echo "---------------------------------------------------"
          echo "Also applying with kubectl to ensure updates..."
          cd $GITHUB_WORKSPACE
          
          # Define namespace and services
          NAMESPACE="${{ secrets.DO_REGISTRY_NAME }}"
          echo "Using namespace: ${NAMESPACE}"
          
          # Apply configurations with kubectl
          echo "Applying configurations directly with kubectl..."
          kubectl get namespace $NAMESPACE || kubectl create namespace $NAMESPACE
          
          # Apply shared resources
          if [ -d "services/shared/k8s" ]; then
            echo "Applying shared resources..."
            kubectl apply -k services/shared/k8s -n $NAMESPACE || true
          fi
          
          # Apply each service's k8s files
          for SERVICE in $SERVICES; do
            if [ -d "services/$SERVICE/k8s" ]; then
              echo "Applying resources for $SERVICE..."
              kubectl apply -k services/$SERVICE/k8s -n $NAMESPACE || true
            fi
          done
          
          echo "Deployment initiated. Services should be updated in Kubernetes."
          
      - name: Create minimal .env file for CI
        run: |
          cat > services/.env << EOF
          # This is an auto-generated .env file for CI deployment
          ENVIRONMENT=${{ env.ENVIRONMENT }}
          
          # DigitalOcean configuration
          DO_REGISTRY_NAME=${{ secrets.DO_REGISTRY_NAME }}
          DO_KUBERNETES_CLUSTER_ID=${{ secrets.DO_KUBERNETES_CLUSTER_ID }}
          
          # Add other CI-specific environment variables here
          NODE_ENV=production
          LOG_LEVEL=info
          
          # Add any additional secrets that deployment scripts need
          QDRANT_HOST=${{ secrets.QDRANT_HOST || 'qdrant.default.svc.cluster.local' }}
          QDRANT_PORT=${{ secrets.QDRANT_PORT || '6333' }}
          POSTGRES_HOST=${{ secrets.POSTGRES_HOST || 'postgres.default.svc.cluster.local' }}
          POSTGRES_PORT=${{ secrets.POSTGRES_PORT || '5432' }}
          REDIS_HOST=${{ secrets.REDIS_HOST || 'redis.default.svc.cluster.local' }}
          REDIS_PORT=${{ secrets.REDIS_PORT || '6379' }}
          EOF
          
          echo "Created CI environment file with necessary deployment variables" 